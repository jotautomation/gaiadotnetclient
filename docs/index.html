<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>.NET Client library for JOT Automation Gaia platform machines </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content=".NET Client library for JOT Automation Gaia platform machines ">
    <meta name="generator" content="docfx 2.44.0.0">
    
    <link rel="shortcut icon" href="favicon.ico">
    <link rel="stylesheet" href="styles/docfx.vendor.css">
    <link rel="stylesheet" href="styles/docfx.css">
    <link rel="stylesheet" href="styles/main.css">
    <meta property="docfx:navrel" content="toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="index.html">
                <img id="logo" class="svg" src="logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        <div class="article row grid">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="net-client-library-for-jot-automation-gaia-platform-machines">.NET Client library for JOT Automation Gaia platform machines</h1>

<h2 id="installation">Installation</h2>
<p>Preferred way is to use <a href="https://www.nuget.org/packages/JOT.GaiaClient/">nuget</a> package. </p>
<h2 id="usage">Usage</h2>
<p>See example program <a href="https://github.com/jotautomation/gaiadotnetclient/blob/master/Example/Program.cs">here</a>.</p>
<p>See API quick start bellow for more information about the API.</p>
<p>On .NET client you will have applications on dictionary. Inside each application on the dictionary there is another dictionary containing the actions for the application. For simple actions you can use simply name of action to call it. For example <code>client.Applications[&quot;SideButtonPusher&quot;].Actions[&quot;Push&quot;]();</code> will activate the side button pusher. </p>
<p>For more complex action you need to add also some fields. So for example recording of wave (audio or other signal) you use this kind of command:  <code>client.Applications[&quot;WaveRecorder&quot;].Actions[&quot;record-wave&quot;](new Dictionary&lt;string, object&gt; { { &quot;time_s&quot;, 2 }, { &quot;filename&quot;, &quot;testrecord.wav&quot; } });</code> </p>
<p>Robot controlling is special case on that sense that the payload on API there is g-code in a plain text form. This is how you execute a robot run <code>client.Applications[&quot;MainRobot&quot;].Actions[&quot;cnc_run&quot;](plainText: &quot;G-CODE AS PLAIN TEXT&quot;);</code></p>
<h1 id="jot-gaia-api-quick-start">JOT Gaia API quick start</h1>
<h2 id="what-it-is">What it is?</h2>
<p>Low-ceremony, simple and self-assisting RestFul API for controlling JOT Automation Gaia platform testers.</p>
<h3 id="browse-the-api">Browse the API</h3>
<p>Use any web browser to browse through the API. Responses are in a JSON format so if your browser doesn&#39;t pretty print JSON automatically, you may want to install an extension that will do it for you. And yes everything you can do with the API is readable from the API itself.</p>
<p>Gaia API follows <a href="https://github.com/kevinswiber/siren">Siren</a> with some additions.</p>
<p>API is found from address [URL]/api, where URL is URL to your gaia machine or virtual gaia instance.</p>
<h2 id="applications">Applications</h2>
<p>Every piece of hardware you want to control is an application. To list applications make GET request to URL/api/applications. You will get list of entities i.e. applications. To get more information about the application make GET request to &quot;href&quot;. Now you will get all information about the application. To control the application see list of  actions on response.</p>
<p>When you need to change state of entity (remember action is an entity), run robot movement or execute any other action, you need to find action field of the entity. Every action has the same structure.</p>
<p>Action defines always:</p>
<ul>
<li>name (name is unique in the context of the gaia machine)</li>
<li>href (URL of the action)</li>
<li>fields (see bellow)</li>
<li>type (content type, almost always application/json)</li>
<li>method (POST or GET)</li>
<li><p>title (Description of what the action does)</p>
<p>If there is limited amount of options on fields they all are listed.</p>
</li>
</ul>
<p>Here I will list some applications types. This is not a comprehensive list of applications. The API itself will guide you to control any type of application and if you need assistance we are happy to help you.</p>
<h3 id="stateful-applications">Stateful applications</h3>
<p>Stateful application is type of application that defines limited number of states. In most cases there is two states: work/home, open/close etc.</p>
<h3 id="cnc-robot">CNC robot</h3>
<p>CNC robot application is type of application that is able to execute robot movements defined as G-code.</p>
<h4 id="stateful-application-action-example">Stateful application action example</h4>
<p>Here is an example of a stateful application action (Snip from GET <a href="http://URL/api/applications/BatteryConnector">http://URL/api/applications/BatteryConnector</a> response)</p>
<pre><code>{
  &quot;type&quot;: &quot;application/json&quot;,
  &quot;href&quot;: &quot;http://URL/api/applications/BatteryConnector/state&quot;,
  &quot;requiredActions&quot;: {},
  &quot;method&quot;: &quot;POST&quot;,
  &quot;stateConditions&quot;: {},
  &quot;title&quot;: &quot;Trigger state change to Home&quot;,
  &quot;name&quot;: &quot;set-Home&quot;,
  &quot;fields&quot;: [
              {
                &quot;type&quot;: &quot;text&quot;,
                &quot;name&quot;: &quot;value&quot;,
                &quot;value&quot;: &quot;Home&quot;
               }
            ]
}
</code></pre><p>As you see there is some additional fields compared to standard action response. Those are used mainly for UI and can be omitted now. We are mainly interested on fields. To &quot;trigger state change to Home&quot;(title) you need to POST(method) to URL(href) with JSON(type) body containing field (fields) that has name &quot;value&quot; with value &quot;Home&quot;. The whole command with cURL tool:</p>
<pre><code>curl -X POST -H &quot;Content-Type: application/json&quot; -d &#39;{&quot;value&quot;:&quot;Work&quot;}&#39; http://URL/api/applications/BatteryConnector/state
</code></pre><h4 id="cnc-robot-application">CNC robot application</h4>
<p>Here is an example of a cnc application action (Snip from GET <a href="http://URL/api/applications/MainRobot">http://URL/api/applications/MainRobot</a> response)</p>
<pre><code>{
  &quot;title&quot;: &quot;Execute CNC/G-code run&quot;,
  &quot;href&quot;: &quot;http://URL/api/applications/MainRobot/cnc_run&quot;,
  &quot;type&quot;: &quot;text/plain&quot;,
  &quot;method&quot;: &quot;POST&quot;,
  &quot;name&quot;: &quot;cnc_run&quot;,
  &quot;fields&quot;: [
              {
              &quot;type&quot;: &quot;text&quot;,
              &quot;name&quot;: &quot;G-code&quot;
              }
            ]
}
</code></pre><p>To &quot;execute CNC/G-code run&quot;(title) you need to POST(method) to URL(href) with text/plain(type) body containing G-code. The whole command with cURL tool:</p>
<pre><code>curl -X POST -H &quot;Content-Type: text/plain&quot; -d &#39;N010 G01 X133.964 Y41.984 Z73.5&#39; http://URL/api/applications/MainRobot/cnc_run
</code></pre><p>This example contains only one line of G-code. Real G-codes are of course longer. Whole G-code is sent as is with linux line endings.</p>
<p>Tool to use with G-code can be set with comment line before real G-code starts. Syntax is &quot;(ToolToUse:Finger1)&quot; without quotes.</p>
<h4 id="state-actions">State actions</h4>
<p>State actions do change state of main state machine. State actions are found from <a href="http://URL/api">http://URL/api</a>.</p>
<h4 id="blocked-actions-vs-actions">Blocked actions vs actions</h4>
<p>If it is not allowed to execute the action, the action is listed under blocked actions instead of actions.</p>
<h2 id="g5-states">G5 States</h2>
<p>G5 tester has rather complex internal state machine that controls the behavior of the G5 tester. This ensures that everything is initializes and so on. Luckily you don&#39;t need to care about the internal state machine. Instead you need to know when G5 tester is ready for testing. For that you just make GET request to URL/api. Returned json contains properties field that contains state field.</p>
<p>States are:</p>
<p><img src="G5States.png" alt="G5/gaia state machine" title="G5/gaia state machine"></p>
<p>Client software must check whether G5 Tester is ready for testing. Testing can be started already when G5 Tester is closing but there is some limitation for tests. Limitations depends on your HW setup but at least there is no RF, audio or other shielding. When testing is ready client software must send release command. </p>
<p>See example program for handling states and sending release command.</p>
<h2 id="client-examples">Client examples</h2>
<p>We have created free open-source clients to help the integration work. Find clients with example code here:</p>
<ul>
<li><a href="https://github.com/jotautomation/gaiadotnetclient">.NET/C#</a></li>
<li><a href="https://github.com/jotautomation/gaiapythonclient">Python</a></li>
</ul>
<h2 id="tips-to-create-your-own-client">Tips to create your own client</h2>
<p>Keep it simple. As you can see from our examples we don&#39;t define application or action types on client side. Instead we call applications and actions by name. This way client side is super thin and still capable of controlling any application. Thus you don&#39;t need to introduce new application type on client side when new application type is introduced on server side.</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="styles/docfx.js"></script>
    <script type="text/javascript" src="styles/main.js"></script>
  </body>
</html>
